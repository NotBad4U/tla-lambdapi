veriT (2021.06-1-g8735d9c-rmx) - the SMT-solver veriT (UFRN/LORIA).
unsat
(assume |ExtTrigEqDef Idv| (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA__TrigEq_Idv smt__x smt__y) (= smt__x smt__y))))
(assume h2 (∈ X S))
(assume |SetStDef TLA__SetSt_flatnd_1| (forall ((smt__a Idv) (smt__x Idv)) (= (∈ smt__x (T smt__a)) (and (∈ smt__x smt__a) (not (∈ smt__x (FunApp f_ smt__x)))))))
(assume |Goal| (not (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S)))))
(step t5 (cl (not (not (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))))) (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) :rule not_not)
(step t6 (cl (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) :rule th_resolution :premises (t5 |Goal|))

(anchor :step t7 :args ((:= (smt__x Idv) vr52) (:= (smt__y Idv) vr53)))
(step t7.t1 (cl (= smt__x vr52)) :rule refl)
(step t7.t2 (cl (= smt__y vr53)) :rule refl)
(step t7.t3 (cl (= (smt__TLA__TrigEq_Idv smt__x smt__y) (smt__TLA__TrigEq_Idv vr52 vr53))) :rule cong :premises (t7.t1 t7.t2))
(step t7.t4 (cl (= smt__x vr52)) :rule refl)
(step t7.t5 (cl (= smt__y vr53)) :rule refl)
(step t7.t6 (cl (= (= smt__x smt__y) (= vr52 vr53))) :rule cong :premises (t7.t4 t7.t5))
(step t7.t7 (cl (= (= (smt__TLA__TrigEq_Idv smt__x smt__y) (= smt__x smt__y)) (= (smt__TLA__TrigEq_Idv vr52 vr53) (= vr52 vr53)))) :rule cong :premises (t7.t3 t7.t6))
(step t7 (cl (= (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA__TrigEq_Idv smt__x smt__y) (= smt__x smt__y))) (forall ((vr52 Idv) (vr53 Idv)) (= (smt__TLA__TrigEq_Idv vr52 vr53) (= vr52 vr53))))) :rule bind)

(step t8 (cl (not (= (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA__TrigEq_Idv smt__x smt__y) (= smt__x smt__y))) (forall ((vr52 Idv) (vr53 Idv)) (= (smt__TLA__TrigEq_Idv vr52 vr53) (= vr52 vr53))))) (not (forall ((smt__x Idv) (smt__y Idv)) (= (smt__TLA__TrigEq_Idv smt__x smt__y) (= smt__x smt__y)))) (forall ((vr52 Idv) (vr53 Idv)) (= (smt__TLA__TrigEq_Idv vr52 vr53) (= vr52 vr53)))) :rule equiv_pos2)
(step t9 (cl (forall ((vr52 Idv) (vr53 Idv)) (= (smt__TLA__TrigEq_Idv vr52 vr53) (= vr52 vr53)))) :rule th_resolution :premises (|ExtTrigEqDef Idv| t7 t8))

(anchor :step t10 :args ((:= (vr52 Idv) vr54) (:= (vr53 Idv) vr55)))
(step t10.t1 (cl (= vr52 vr54)) :rule refl)
(step t10.t2 (cl (= vr53 vr55)) :rule refl)
(step t10.t3 (cl (= (smt__TLA__TrigEq_Idv vr52 vr53) (smt__TLA__TrigEq_Idv vr54 vr55))) :rule cong :premises (t10.t1 t10.t2))
(step t10.t4 (cl (= vr52 vr54)) :rule refl)
(step t10.t5 (cl (= vr53 vr55)) :rule refl)
(step t10.t6 (cl (= (= vr52 vr53) (= vr54 vr55))) :rule cong :premises (t10.t4 t10.t5))
(step t10.t7 (cl (= (= (smt__TLA__TrigEq_Idv vr52 vr53) (= vr52 vr53)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) :rule cong :premises (t10.t3 t10.t6))
(step t10 (cl (= (forall ((vr52 Idv) (vr53 Idv)) (= (smt__TLA__TrigEq_Idv vr52 vr53) (= vr52 vr53))) (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55))))) :rule bind)

(step t11 (cl (not (= (forall ((vr52 Idv) (vr53 Idv)) (= (smt__TLA__TrigEq_Idv vr52 vr53) (= vr52 vr53))) (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55))))) (not (forall ((vr52 Idv) (vr53 Idv)) (= (smt__TLA__TrigEq_Idv vr52 vr53) (= vr52 vr53)))) (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) :rule equiv_pos2)
(step t12 (cl (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) :rule th_resolution :premises (t9 t10 t11))
(anchor :step t13 :args ((:= (smt__a Idv) vr56) (:= (smt__x Idv) vr57)))
(step t13.t1 (cl (= smt__x vr57)) :rule refl)
(step t13.t2 (cl (= smt__a vr56)) :rule refl)
(step t13.t3 (cl (= (T smt__a) (T vr56))) :rule cong :premises (t13.t2))
(step t13.t4 (cl (= (∈ smt__x (T smt__a)) (∈ vr57 (T vr56)))) :rule cong :premises (t13.t1 t13.t3))
(step t13.t5 (cl (= smt__x vr57)) :rule refl)
(step t13.t6 (cl (= smt__a vr56)) :rule refl)
(step t13.t7 (cl (= (∈ smt__x smt__a) (∈ vr57 vr56))) :rule cong :premises (t13.t5 t13.t6))
(step t13.t8 (cl (= smt__x vr57)) :rule refl)
(step t13.t9 (cl (= smt__x vr57)) :rule refl)
(step t13.t10 (cl (= (FunApp f_ smt__x) (FunApp f_ vr57))) :rule cong :premises (t13.t9))
(step t13.t11 (cl (= (∈ smt__x (FunApp f_ smt__x)) (∈ vr57 (FunApp f_ vr57)))) :rule cong :premises (t13.t8 t13.t10))
(step t13.t12 (cl (= (not (∈ smt__x (FunApp f_ smt__x))) (not (∈ vr57 (FunApp f_ vr57))))) :rule cong :premises (t13.t11))
(step t13.t13 (cl (= (and (∈ smt__x smt__a) (not (∈ smt__x (FunApp f_ smt__x)))) (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57)))))) :rule cong :premises (t13.t7 t13.t12))
(step t13.t14 (cl (= (= (∈ smt__x (T smt__a)) (and (∈ smt__x smt__a) (not (∈ smt__x (FunApp f_ smt__x))))) (= (∈ vr57 (T vr56)) (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57))))))) :rule cong :premises (t13.t4 t13.t13))
(step t13 (cl (= (forall ((smt__a Idv) (smt__x Idv)) (= (∈ smt__x (T smt__a)) (and (∈ smt__x smt__a) (not (∈ smt__x (FunApp f_ smt__x)))))) (forall ((vr56 Idv) (vr57 Idv)) (= (∈ vr57 (T vr56)) (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57)))))))) :rule bind)
(step t14 (cl (not (= (forall ((smt__a Idv) (smt__x Idv)) (= (∈ smt__x (T smt__a)) (and (∈ smt__x smt__a) (not (∈ smt__x (FunApp f_ smt__x)))))) (forall ((vr56 Idv) (vr57 Idv)) (= (∈ vr57 (T vr56)) (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57)))))))) (not (forall ((smt__a Idv) (smt__x Idv)) (= (∈ smt__x (T smt__a)) (and (∈ smt__x smt__a) (not (∈ smt__x (FunApp f_ smt__x))))))) (forall ((vr56 Idv) (vr57 Idv)) (= (∈ vr57 (T vr56)) (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57))))))) :rule equiv_pos2)
(step t15 (cl (forall ((vr56 Idv) (vr57 Idv)) (= (∈ vr57 (T vr56)) (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57))))))) :rule th_resolution :premises (|SetStDef TLA__SetSt_flatnd_1| t13 t14))
(anchor :step t16 :args ((:= (vr56 Idv) vr58) (:= (vr57 Idv) vr59)))
(step t16.t1 (cl (= vr57 vr59)) :rule refl)
(step t16.t2 (cl (= vr56 vr58)) :rule refl)
(step t16.t3 (cl (= (T vr56) (T vr58))) :rule cong :premises (t16.t2))
(step t16.t4 (cl (= (∈ vr57 (T vr56)) (∈ vr59 (T vr58)))) :rule cong :premises (t16.t1 t16.t3))
(step t16.t5 (cl (= vr57 vr59)) :rule refl)
(step t16.t6 (cl (= vr56 vr58)) :rule refl)
(step t16.t7 (cl (= (∈ vr57 vr56) (∈ vr59 vr58))) :rule cong :premises (t16.t5 t16.t6))
(step t16.t8 (cl (= vr57 vr59)) :rule refl)
(step t16.t9 (cl (= vr57 vr59)) :rule refl)
(step t16.t10 (cl (= (FunApp f_ vr57) (FunApp f_ vr59))) :rule cong :premises (t16.t9))
(step t16.t11 (cl (= (∈ vr57 (FunApp f_ vr57)) (∈ vr59 (FunApp f_ vr59)))) :rule cong :premises (t16.t8 t16.t10))
(step t16.t12 (cl (= (not (∈ vr57 (FunApp f_ vr57))) (not (∈ vr59 (FunApp f_ vr59))))) :rule cong :premises (t16.t11))
(step t16.t13 (cl (= (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57)))) (and (∈ vr59 vr58) (not (∈ vr59 (FunApp f_ vr59)))))) :rule cong :premises (t16.t7 t16.t12))
(step t16.t14 (cl (= (= (∈ vr57 (T vr56)) (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57))))) (= (∈ vr59 (T vr58)) (and (∈ vr59 vr58) (not (∈ vr59 (FunApp f_ vr59))))))) :rule cong :premises (t16.t4 t16.t13))
(step t16 (cl (= (forall ((vr56 Idv) (vr57 Idv)) (= (∈ vr57 (T vr56)) (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57)))))) (forall ((vr58 Idv) (vr59 Idv)) (= (∈ vr59 (T vr58)) (and (∈ vr59 vr58) (not (∈ vr59 (FunApp f_ vr59)))))))) :rule bind)
(step t17 (cl (not (= (forall ((vr56 Idv) (vr57 Idv)) (= (∈ vr57 (T vr56)) (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57)))))) (forall ((vr58 Idv) (vr59 Idv)) (= (∈ vr59 (T vr58)) (and (∈ vr59 vr58) (not (∈ vr59 (FunApp f_ vr59)))))))) (not (forall ((vr56 Idv) (vr57 Idv)) (= (∈ vr57 (T vr56)) (and (∈ vr57 vr56) (not (∈ vr57 (FunApp f_ vr57))))))) (forall ((vr58 Idv) (vr59 Idv)) (= (∈ vr59 (T vr58)) (and (∈ vr59 vr58) (not (∈ vr59 (FunApp f_ vr59))))))) :rule equiv_pos2)
(step t18 (cl (forall ((vr58 Idv) (vr59 Idv)) (= (∈ vr59 (T vr58)) (and (∈ vr59 vr58) (not (∈ vr59 (FunApp f_ vr59))))))) :rule th_resolution :premises (t15 t16 t17))
(step t19 (cl (or (not (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) (forall ((vr54 Idv) (vr55 Idv)) (or (not (smt__TLA__TrigEq_Idv vr54 vr55)) (= vr54 vr55))))) :rule qnt_cnf)
(step t20 (cl (not (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) (forall ((vr54 Idv) (vr55 Idv)) (or (not (smt__TLA__TrigEq_Idv vr54 vr55)) (= vr54 vr55)))) :rule or :premises (t19))
(step t21 (cl (or (not (forall ((vr54 Idv) (vr55 Idv)) (or (not (smt__TLA__TrigEq_Idv vr54 vr55)) (= vr54 vr55)))) (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X))))) :rule forall_inst :args ((:= vr54 (FunApp f_ X)) (:= vr55 (T S))))
(step t22 (cl (not (forall ((vr54 Idv) (vr55 Idv)) (or (not (smt__TLA__TrigEq_Idv vr54 vr55)) (= vr54 vr55)))) (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X)))) :rule or :premises (t21))
(step t23 (cl (or (not (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X)))) (not (not (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))))) :rule or_neg)
(step t24 (cl (not (not (not (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))))) (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) :rule not_not)
(step t25 (cl (or (not (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X)))) (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) :rule th_resolution :premises (t24 t23))
(step t26 (cl (or (not (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X)))) (not (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X))))) :rule or_neg)
(step t27 (cl (or (not (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X))))) :rule th_resolution :premises (t20 t22 t25 t26))
(step t28 (cl (not (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X)))) (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X))) :rule or_pos)
(step t29 (cl (not (forall ((vr54 Idv) (vr55 Idv)) (= (smt__TLA__TrigEq_Idv vr54 vr55) (= vr54 vr55)))) (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X)))) :rule or :premises (t27))
(step t30 (cl (not (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X)))) (= (T S) (FunApp f_ X))) :rule resolution :premises (t28 t6))
(step t31 (cl (or (not (smt__TLA__TrigEq_Idv (FunApp f_ X) (T S))) (= (T S) (FunApp f_ X)))) :rule resolution :premises (t29 t12))
(step t32 (cl (= (T S) (FunApp f_ X))) :rule resolution :premises (t30 t31))
(step t33 (cl (or (not (forall ((vr58 Idv) (vr59 Idv)) (= (∈ vr59 (T vr58)) (and (∈ vr59 vr58) (not (∈ vr59 (FunApp f_ vr59))))))) (= (∈ X (T S)) (and (∈ X S) (not (∈ X (FunApp f_ X))))))) :rule forall_inst :args ((:= vr58 S) (:= vr59 X)))
(step t34 (cl (not (and (∈ X S) (not (∈ X (FunApp f_ X))))) (not (∈ X (FunApp f_ X)))) :rule and_pos)
(step t35 (cl (and (∈ X S) (not (∈ X (FunApp f_ X)))) (not (∈ X S)) (not (not (∈ X (FunApp f_ X))))) :rule and_neg)
(step t36 (cl (not (not (not (∈ X (FunApp f_ X))))) (∈ X (FunApp f_ X))) :rule not_not)
(step t37 (cl (and (∈ X S) (not (∈ X (FunApp f_ X)))) (not (∈ X S)) (∈ X (FunApp f_ X))) :rule th_resolution :premises (t36 t35))
(step t38 (cl (not (= (∈ X (T S)) (and (∈ X S) (not (∈ X (FunApp f_ X)))))) (∈ X (T S)) (not (and (∈ X S) (not (∈ X (FunApp f_ X)))))) :rule equiv_pos1)
(step t39 (cl (not (= (∈ X (T S)) (and (∈ X S) (not (∈ X (FunApp f_ X)))))) (not (∈ X (T S))) (and (∈ X S) (not (∈ X (FunApp f_ X))))) :rule equiv_pos2)
(step t40 (cl (not (forall ((vr58 Idv) (vr59 Idv)) (= (∈ vr59 (T vr58)) (and (∈ vr59 vr58) (not (∈ vr59 (FunApp f_ vr59))))))) (= (∈ X (T S)) (and (∈ X S) (not (∈ X (FunApp f_ X)))))) :rule or :premises (t33))
(step t41 (cl (and (∈ X S) (not (∈ X (FunApp f_ X)))) (∈ X (FunApp f_ X))) :rule resolution :premises (t37 h2))
(step t42 (cl (= (∈ X (T S)) (and (∈ X S) (not (∈ X (FunApp f_ X)))))) :rule resolution :premises (t40 t18))
(step t43 (cl (not (= X X)) (not (= (T S) (FunApp f_ X))) (not (∈ X (T S))) (∈ X (FunApp f_ X))) :rule eq_congruent_pred)
(step t44 (cl (= X X)) :rule eq_reflexive)
(step t45 (cl (not (= (T S) (FunApp f_ X))) (not (∈ X (T S))) (∈ X (FunApp f_ X))) :rule th_resolution :premises (t43 t44))
(step t46 (cl (not (∈ X (T S))) (∈ X (FunApp f_ X))) :rule resolution :premises (t45 t32))
(step t47 (cl (∈ X (FunApp f_ X))) :rule resolution :premises (t46 t38 t41 t42))
(step t48 (cl (not (and (∈ X S) (not (∈ X (FunApp f_ X)))))) :rule resolution :premises (t34 t47))
(step t49 (cl (not (∈ X (T S)))) :rule resolution :premises (t39 t48 t42))
(step t50 (cl (not (= X X)) (not (= (T S) (FunApp f_ X))) (not (∈ X (FunApp f_ X))) (∈ X (T S))) :rule eq_congruent_pred)
(step t51 (cl (not (= (T S) (FunApp f_ X))) (not (∈ X (FunApp f_ X))) (∈ X (T S))) :rule th_resolution :premises (t50 t44))
(step t52 (cl) :rule resolution :premises (t51 t32 t49 t47))
